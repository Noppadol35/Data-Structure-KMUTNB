# Q1: สร้างและแสดงผล Matrix

ให้เขียนโปรแกรมเพื่อสร้างและแสดงผล 2D matrix โดยกำหนดเงื่อนไขในการรับค่าและการแสดงผลดังนี้:

## เงื่อนไขการรับค่าและการสร้าง Matrix

1. รับค่าจำนวนเต็ม 3 ค่าคือ `num`, `n` และ `m`
   - `num` คือจำนวนตัวเลขที่สามารถใส่ค่าใน matrix ได้
   - `n` คือจำนวนแถวของ matrix
   - `m` คือจำนวนคอลัมน์ของ matrix

2. ให้สร้าง matrix ขนาด `n x m` และกำหนดค่าเริ่มต้นให้ทุกช่องของ matrix เป็น `0`

3. รับค่าอีก `num` ค่าเก็บไว้ใน array `values` โดยค่าที่รับมาให้นำไปเติมลงใน matrix โดยเริ่มจากแถวแรกสุดและเติมจากซ้ายไปขวา หากเติมครบ `num` ค่าแล้ว ให้ช่องที่เหลือเป็น `0`

## เงื่อนไขการแสดงผล

1. แสดง matrix ที่เติมค่าเรียบร้อยแล้ว โดยในแต่ละแถวให้แสดงผลรวมของแถวนั้นทางด้านขวา
2. แสดงผลรวมของแต่ละคอลัมน์ที่ด้านล่างของ matrix และแสดงผลรวมทั้งหมดของคอลัมน์ด้านขวาสุดของผลรวมคอลัมน์

## ตัวอย่าง Input และ Output

**ตัวอย่างที่ 1:**
input
```
6 2 3
1 2 3 4 5 6
```
output
```
1 2 3 = 6
4 5 6 = 15
5 7 9 = 21
```

**ตัวอย่างที่ 2:**
input
```
6 3 2
1 2 3 4 5 6
```
output
```
1 2 = 3
3 4 = 7
5 6 = 11
9 12 = 21
```

**ตัวอย่างที่ 3:**
input
```
4 2 3
1000 1000 1000 1000
```
output
```
1000 1000 1000 = 3000
1000 0    0    = 1000
2000 1000 1000 = 4000
```

## เงื่อนไขเพิ่มเติม

- ขนาดของ matrix (จำนวนแถวและคอลัมน์) จะไม่เกิน 100 x 100
- สามารถใช้โครงสร้างข้อมูลใดก็ได้ตามที่ถนัด

# Q2: สร้าง Max-Heap และจัดการข้อมูลใน Heap

ให้เขียนโปรแกรมสำหรับจัดการ Max-Heap โดยโปรแกรมจะมีการเพิ่มข้อมูล, ลบข้อมูล, แสดงข้อมูล, และค้นหาข้อมูลตามตำแหน่งใน Heap

## คำอธิบาย

1. โปรแกรมมีการสร้างคลาส `Heap` ที่ใช้ array `q[1000]` ในการจัดเก็บข้อมูล โดย `q[0]` ใช้เก็บขนาดของ heap ส่วนตำแหน่งที่เหลือใช้เก็บข้อมูลจริง
2. คลาส `Heap` จะต้องมีฟังก์ชันต่าง ๆ เพื่อจัดการกับ Max-Heap เช่นการเพิ่มข้อมูล (`insert`), ลบข้อมูล (`remove`), การเรียง heap ใหม่ (`heapify`), แสดงข้อมูล (`print`), และค้นหาข้อมูลที่ตำแหน่งที่กำหนด (`findAtPosition`)

## การทำงานของโปรแกรม

โปรแกรมจะรับคำสั่งจากผู้ใช้เพื่อทำการจัดการ heap ตามฟังก์ชันต่าง ๆ ดังนี้:

### คำสั่งที่โปรแกรมรองรับ

- `a <value>` : เพิ่มข้อมูล `<value>` ลงใน heap
- `p` : แสดงค่าทั้งหมดใน heap
- `d` : ลบค่า root ออกจาก heap และแสดงค่าที่ถูกลบออก
- `k <position>` : ค้นหาค่าที่ตำแหน่ง `<position>` ใน heap และแสดงค่าในตำแหน่งนั้น
- `e` : ออกจากโปรแกรม

### ฟังก์ชันที่ต้องการในคลาส `Heap`

1. **insert(int n)**: เพิ่มข้อมูล `n` ลงใน heap และปรับค่า heap ให้ถูกต้องโดยใช้ฟังก์ชัน `heapify`
2. **heapify()**: จัดเรียงค่าใน heap ให้เป็น Max-Heap (ค่า root จะต้องมากที่สุด) หลังจากการเพิ่มหรือลบข้อมูล
3. **remove()**: ลบค่า root (ค่าที่มากที่สุดใน heap) ออกจาก heap และเรียก `heapify` เพื่อจัดเรียง heap ใหม่
4. **print()**: แสดงค่าทั้งหมดที่มีใน heap เรียงตามลำดับตำแหน่งใน array
5. **findAtPosition(int k)**: ค้นหาค่าที่ตำแหน่ง `k` ใน heap หากตำแหน่ง `k` อยู่ภายในขอบเขตที่ถูกต้อง ให้แสดงค่าที่ตำแหน่งนั้น มิฉะนั้นให้แสดงข้อความว่า `"Invalid position!"`

## ข้อกำหนดเพิ่มเติม

- ขนาดของ heap สูงสุดคือ 1000
- ใช้คำสั่งในฟังก์ชัน `main` เพื่อรับคำสั่งจากผู้ใช้ และดำเนินการตามฟังก์ชันที่กำหนดไว้ในคลาส `Heap`



## ในตัวอย่างข้างต้น:
- คำสั่ง `a` ใช้สำหรับเพิ่มค่าใน heap
- คำสั่ง `p` ใช้สำหรับแสดงค่าใน heap ทั้งหมด
- คำสั่ง `d` ใช้สำหรับลบค่า root ของ heap และแสดงค่าที่ถูกลบออกมา
- คำสั่ง `k` ใช้สำหรับค้นหาค่าที่ตำแหน่งที่กำหนดใน heap

## ตัวอย่าง Input และ Output

**ตัวอย่างที่ 1**

input
```
Input: a 10 a 20 a 15 p d p k 2 e

Output: 20 10 15 20 15 10 Value at position 2 is: 10
```

**ตัวอย่างที่ 2**
```
Input: a 5 a 7 a 3 a 2 p k 5 e

Output: 7 5 3 2 Invalid position!
```

# Q3: การจัดการข้อมูลใน Binary Search Tree (BST)

ให้เขียนโปรแกรมสำหรับจัดการข้อมูลใน Binary Search Tree (BST) โดยโปรแกรมจะสามารถเพิ่ม, ลบ, และแสดงข้อมูลในรูปแบบต่าง ๆ เช่น Preorder, Inorder, Postorder, และ Breadth-First Traversal (BFS)

## คำอธิบาย

1. โปรแกรมมีการสร้างโครงสร้างข้อมูล `NODE` ที่ประกอบด้วยข้อมูล (`data`) และตัวชี้ (`left`, `right`) ไปยังโหนดลูกด้านซ้ายและขวา
2. ในการทำงานของโปรแกรม มีฟังก์ชันต่าง ๆ ที่จัดการ BST เช่นการเพิ่มโหนด (`add_node`), ลบโหนด (`delete_node`), และแสดงผลในรูปแบบต่าง ๆ
3. ผู้ใช้จะใช้คำสั่งต่าง ๆ เพื่อจัดการข้อมูลใน BST ผ่านฟังก์ชันที่กำหนด

## คำสั่งที่โปรแกรมรองรับ

โปรแกรมสามารถรับคำสั่งต่าง ๆ จากผู้ใช้เพื่อตอบสนองการจัดการข้อมูลใน BST ดังนี้:

### คำสั่งที่มีให้ใช้งาน

- `a <data>` : เพิ่มข้อมูล `<data>` ลงใน BST
- `d <data>` : ลบข้อมูล `<data>` ออกจาก BST
- `p` : แสดงข้อมูลทั้งหมดใน BST ด้วยการ Traverse แบบ Preorder
- `i` : แสดงข้อมูลทั้งหมดใน BST ด้วยการ Traverse แบบ Inorder
- `t` : แสดงข้อมูลทั้งหมดใน BST ด้วยการ Traverse แบบ Postorder
- `b` : แสดงข้อมูลทั้งหมดใน BST ด้วยการ Traverse แบบ Breadth-First (BFS) โดยแยกแต่ละระดับด้วยเครื่องหมาย `|`
- `x` : ออกจากโปรแกรม

## ฟังก์ชันที่ต้องการในโปรแกรม

1. **add_node(NODE**`**currentnode, int new_data`**)** : เพิ่มข้อมูลใหม่ลงใน BST โดยการค้นหาตำแหน่งที่เหมาะสมและเพิ่มข้อมูลใหม่ในรูปแบบของ Binary Search Tree
2. **delete_node(NODE**`*root, int data`**)** : ลบโหนดที่มีข้อมูลตรงกับ `data` ออกจาก BST โดยมีเงื่อนไขต่าง ๆ ในการลบ (ไม่มีลูก, มีลูก 1 โหนด, มีลูก 2 โหนด)
3. **preorder(NODE**`*node`**)** : แสดงข้อมูลทั้งหมดใน BST ด้วยการ Traverse แบบ Preorder (Root -> Left -> Right)
4. **inorder(NODE**`*node`**)** : แสดงข้อมูลทั้งหมดใน BST ด้วยการ Traverse แบบ Inorder (Left -> Root -> Right)
5. **postorder(NODE**`*node`**)** : แสดงข้อมูลทั้งหมดใน BST ด้วยการ Traverse แบบ Postorder (Left -> Right -> Root)
6. **BreadthFirst(NODE**`*root`**)** : แสดงข้อมูลทั้งหมดใน BST ด้วยการ Traverse แบบ Breadth-First (BFS) โดยแยกแต่ละระดับด้วยเครื่องหมาย `|`

> **หมายเหตุ:** ในการแสดงผลข้อมูลแต่ละโหนด ให้ใช้เครื่องหมาย `,` คั่นระหว่างค่า และเมื่อจบการแสดงผลแต่ละคำสั่ง ให้ขึ้นบรรทัดใหม่ด้วยคำสั่ง `endl`

## ตัวอย่าง Input และ Output

**ตัวอย่างที่ 1**
```
Input: a 10 a 5 a 15 a 2 a 7 a 12 a 17 p i t b d 7 i x

Output: 10,5,2,7,15,12,17, 2,5,7,10,12,15,17, 2,7,5,12,17,15,10, 10,|5,15,|2,7,12,17,| 2,5,10,12,15,17,
```